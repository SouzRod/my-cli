'use strict';

const { expect }      = require('chai');
const objSinon        = require('sinon');
cosnt cloneDeep       = require('clone-deep');

const adapters        = require('../../../../v1/adapters');
const <%= name %>Wrapper   = require('../../../../v1/adapters/<%= name %>');
const config          = require('../../../../config');

let mockDependencies;

describe('Unit tests for <%= name %> adapter', () => {
  beforeEach('send message', () => {
    mockDependencies = {
      config,
      headers: {
        host: 'http://localhost:8080',
      },
      payload: {},<% if (resource.includes('mongo')){ %> /* repositoryMongoDb: {
        testCollection: {
          findOne: objSinon.spy(() => Promise.resolve({})),
        },
      }, */<% } %>
      onSuccess: objSinon.spy(onSuccess => onSuccess),
      onError: objSinon.spy(onError => onError),
    };
  });

  context('smoke tests', () => {
    it('should have a handler adapter created', () => {
      const { handler } = adapters(mockDependencies);
      expect(handler).to.be.a('function');
    });

    it('should have a handler <%= name %>Wrapper created', async () => {
      const { handler } = <%= name %>Wrapper(mockDependencies);
      expect(handler).to.be.a('function');
    });
  });

  context('Handler ok', () => {
    it('should return object success when handler method', async () => {
      await <%= name %>Wrapper(mockDependencies).handler(mockDependencies);
      const result = mockDependencies.onSuccess.returnValues[0];<% if (type == 'docker'){ %>
      expect(result).to.be.contain('Running application on port 3001...');<% } %><% if (type == 'serverless'){ %>
      expect(result).to.be.contain('Event lambda...');<% } %>
    });
  });

  context('Handler error', () => {
    it('should return error 500 in handler method', async () => {
      const dependencies = cloneDeep(mockDependencies);
      dependencies.config = null;
      const result = await <%= name %>Wrapper(dependencies).handler(dependencies);
      expect(result).to.have.property('stack');
      expect(result).to.have.property('message');
    });
  });
});
